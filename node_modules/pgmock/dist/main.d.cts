import * as net from 'net';
import { EventEmitter } from 'events';

declare class Ipv4Address {
    static ZeroAddress: Ipv4Address;
    static BroadcastAddress: Ipv4Address;
    readonly bytes: Uint8Array;
    constructor(bytes: Iterable<number>);
    constructor(str: string);
    bitNot(): Ipv4Address;
    bitAnd(other: Ipv4Address): Ipv4Address;
    bitOr(other: Ipv4Address): Ipv4Address;
    bitXor(other: Ipv4Address): Ipv4Address;
    equals(other: Ipv4Address): boolean;
    isRecipientOfTarget(targetAddress: Ipv4Address): boolean;
    toString(): string;
    toInt(): number;
    static _fromSignedInt(signedInt: number): Ipv4Address;
    static fromInt(int: number): Ipv4Address;
}

declare class MacAddress {
    static ZeroAddress: MacAddress;
    static BroadcastAddress: MacAddress;
    readonly bytes: Uint8Array;
    constructor(bytes: Iterable<number>);
    constructor(str: string);
    equals(other: MacAddress): boolean;
    isRecipientOfTarget(targetAddress: MacAddress): boolean;
    toString(): string;
}

type HandlerContext<ReceiveFrame extends object, ReceiveData extends object, SendFrame extends object, SendData extends object> = {
    onProcessFrame: (callback: (frame: ReceiveFrame) => {
        consumed: boolean;
    }) => void;
    processData: (data: ReceiveData) => void;
    sendFrame: (frame: SendFrame) => void;
    onSendData: (callback: (data: SendData) => void) => void;
};
type ProtocolOptions<SubProtocols extends Record<string, Protocol<any, any, any, any, any>>> = {
    protocols: SubProtocols;
};
type SubProtocolFor<P extends AnyProtocol> = Protocol<P[TypeInformation]["ReceiveData"], any, P[TypeInformation]["SendData"], any, {}, {}> | Protocol<P[TypeInformation]["ReceiveData"], never, P[TypeInformation]["SendData"], never, {}, {}>;
type AnyProtocol = SubProtocolFor<any>;
type ProtocolHandler<P extends AnyProtocol> = ProtocolHandlerInner<P[TypeInformation]["ReceiveFrame"], P[TypeInformation]["ReceiveData"], P[TypeInformation]["SendFrame"], P[TypeInformation]["SendData"], P[TypeInformation]["SubProtocols"]>;
type ProtocolHandlerInner<ReceiveFrame extends object, ReceiveData extends object, SendFrame extends object, SendData extends object, SubProtocols extends Record<string, AnyProtocol>> = {
    protocols: {
        [K in keyof SubProtocols]: ReturnType<SubProtocols[K]["createHandler"]>;
    };
    onReceiveFrame: (callback: (frame: ReceiveFrame) => void) => (() => void);
    onReceiveData: (callback: (data: ReceiveData) => void) => (() => void);
    onSendFrame: (callback: (frame: SendFrame) => void) => (() => void);
    onSendData: (callback: (data: SendData) => void) => (() => void);
    destroy: () => void;
};
declare const typeInformation = "__hiddenTypeInformationDoesNotExistAtRuntime";
type TypeInformation = typeof typeInformation;
declare abstract class Protocol<ReceiveFrame extends object, ReceiveData extends object, SendFrame extends object, SendData extends object, SubProtocols extends Record<string, Protocol<ReceiveData, any, SendData, any, any>>, AdditionalOptions extends object = {}> {
    [typeInformation]: {
        ReceiveFrame: ReceiveFrame;
        ReceiveData: ReceiveData;
        SendFrame: SendFrame;
        SendData: SendData;
        SubProtocols: SubProtocols;
        AdditionalOptions: AdditionalOptions;
    };
    readonly options: {
        protocols: {};
    } & Partial<ProtocolOptions<SubProtocols>> & AdditionalOptions;
    constructor(options: Partial<ProtocolOptions<SubProtocols>> & AdditionalOptions);
    abstract get displayName(): string;
    abstract createHandler(base: ProtocolHandler<this>, context: HandlerContext<ReceiveFrame, ReceiveData, SendFrame, SendData>): ProtocolHandler<this>;
}

type EthernetFrame = Uint8Array;
type EthernetData = {
    srcMac: MacAddress;
    destMac: MacAddress;
    etherType: number;
    payload: Uint8Array;
};
type SubProtocol$6 = SubProtocolFor<Ethernet>;
declare class Ethernet<SubProtocols extends {
    [K in string]: SubProtocol$6;
} = any> extends Protocol<EthernetFrame, EthernetData, EthernetFrame, EthernetData, SubProtocols> {
    readonly displayName = "Ethernet";
    constructor(options: Partial<ProtocolOptions<SubProtocols>>);
    createHandler(base: ProtocolHandler<this>, context: HandlerContext<EthernetFrame, EthernetData, EthernetFrame, EthernetData>): ProtocolHandler<this>;
}

type ArpFrame = EthernetData;
type ArpDataInner<HardwareType extends number, HardwareAddressKeyName extends string, HardwareAddress, ProtocolType extends number, ProtocolAddressKeyName extends string, ProtocolAddress> = {
    srcMac: MacAddress;
    destMac: MacAddress;
    hardwareType: HardwareType;
    protocolType: ProtocolType;
    hardwareSize: number;
    protocolSize: number;
} & (({
    operation: 0x1;
} & Record<`origin${HardwareAddressKeyName}`, HardwareAddress> & Record<`origin${ProtocolAddressKeyName}`, ProtocolAddress> & Record<`queried${ProtocolAddressKeyName}`, ProtocolAddress>) | ({
    operation: 0x2;
} & Record<`queried${HardwareAddressKeyName}`, HardwareAddress> & Record<`queried${ProtocolAddressKeyName}`, ProtocolAddress> & Record<`origin${HardwareAddressKeyName}`, HardwareAddress> & Record<`origin${ProtocolAddressKeyName}`, ProtocolAddress>));
type ArpData = ArpDataInner<0x1, "Mac", MacAddress, 0x0800, "Ip", Ipv4Address>;
type SubProtocol$5 = SubProtocolFor<Arp>;
declare class Arp<SubProtocols extends {
    [K in string]: SubProtocol$5;
} = any> extends Protocol<ArpFrame, ArpData, ArpFrame, ArpData, SubProtocols> {
    readonly displayName = "ARP";
    etherType: number;
    constructor(options: Partial<ProtocolOptions<SubProtocols>>);
    createHandler(base: ProtocolHandler<this>, context: HandlerContext<ArpFrame, ArpData, ArpFrame, ArpData>): ProtocolHandler<this>;
}

type UdpFrame = Ipv4Data;
type UdpData = {
    srcIp: Ipv4Address;
    destIp: Ipv4Address;
    srcPort: number;
    destPort: number;
    payload: Uint8Array;
};
type SubProtocol$4 = SubProtocolFor<Udp>;
declare class Udp<SubProtocols extends {
    [K in string]: SubProtocol$4;
} = any> extends Protocol<UdpFrame, UdpData, UdpFrame, UdpData, SubProtocols> {
    readonly displayName = "UDP";
    readonly ipProtocolNumber = 17;
    constructor(options: Partial<ProtocolOptions<SubProtocols>>);
    createHandler(base: ProtocolHandler<this>, context: HandlerContext<UdpFrame, UdpData, UdpFrame, UdpData>): ProtocolHandler<this>;
}

type DhcpFrame = UdpData;
type DhcpData = {
    srcIp: Ipv4Address;
    destIp: Ipv4Address;
    srcPort: number;
    destPort: number;
    operation: number;
    hops: number;
    xid: number;
    seconds: number;
    flags: number;
    clientIpAddress: Ipv4Address;
    yourIpAddress: Ipv4Address;
    serverIpAddress: Ipv4Address;
    gatewayIpAddress: Ipv4Address;
    serverName: string | null;
    bootFileName: string | null;
    options: {
        code: number;
        data: Uint8Array;
    }[];
} & ({
    hardwareType: 1;
    hardwareAddressLength: 6;
    clientHardwareAddress: MacAddress;
});
type SubProtocol$3 = SubProtocolFor<Dhcp>;
declare class Dhcp<SubProtocols extends {
    [K in string]: SubProtocol$3;
} = any> extends Protocol<DhcpFrame, DhcpData, DhcpFrame, DhcpData, SubProtocols> {
    readonly displayName = "DHCP";
    constructor(options: Partial<ProtocolOptions<SubProtocols>>);
    createHandler(base: ProtocolHandler<this>, context: HandlerContext<DhcpFrame, DhcpData, DhcpFrame, DhcpData>): ProtocolHandler<this>;
}

declare class ArpImplementation extends Protocol<ArpData, never, ArpData, never, {}, {
    router: Router;
}> {
    readonly displayName = "RouterARP";
    constructor(router: Router);
    createHandler(base: ProtocolHandler<this>, context: HandlerContext<ArpData, never, ArpData, never>): ProtocolHandler<this>;
}
declare class DhcpImplementation extends Protocol<DhcpData, never, DhcpData, never, {}, {
    router: Router;
}> {
    readonly displayName = "RouterDHCP";
    constructor(router: Router);
    createHandler(base: ProtocolHandler<this>, context: HandlerContext<DhcpData, never, DhcpData, never>): ProtocolHandler<this>;
}
type Device = {
    readonly mac: MacAddress;
    readonly ip: Ipv4Address;
    readonly isConfirmed: boolean;
    confirm(): void;
};
declare class Router implements Device {
    static ArpImplementation: typeof ArpImplementation;
    static DhcpImplementation: typeof DhcpImplementation;
    readonly mac: MacAddress;
    readonly ip: Ipv4Address;
    readonly isConfirmed: true;
    readonly subnetMask: Ipv4Address;
    private _addressTable;
    private _devices;
    constructor(options: {
        mac: MacAddress;
        ip: Ipv4Address;
        subnetMask: Ipv4Address;
    });
    get subnet(): Ipv4Address;
    confirm(): void;
    registerDevice(mac: MacAddress): Device | undefined;
    private _registerDevice;
    private _getNextFreeIp;
    getDevice(mac: MacAddress): Device | undefined;
    getDevice(ip: Ipv4Address): Device | undefined;
    getOrRegisterDevice(mac: MacAddress): Device | undefined;
    listDevices(): Device[];
    isIpAssigned(ip: Ipv4Address): boolean;
}

type Ipv4Frame = EthernetData;
type Ipv4Data = {
    srcIp: Ipv4Address;
    destIp: Ipv4Address;
    flags: {
        dontFragment: boolean;
    };
    protocol: number;
    timeToLive: number;
    dscp: number;
    ecn: number;
    payload: Uint8Array;
};
type SubProtocol$2 = SubProtocolFor<Ipv4>;
declare class Ipv4<SubProtocols extends {
    [K in string]: SubProtocol$2;
} = any> extends Protocol<Ipv4Frame, Ipv4Data, Ipv4Frame, Ipv4Data, SubProtocols, {
    router: Router;
}> {
    readonly displayName = "IPv4";
    readonly etherType = 2048;
    constructor(options: Partial<ProtocolOptions<SubProtocols>> & {
        router: Router;
    });
    createHandler(base: ProtocolHandler<this>, context: HandlerContext<Ipv4Frame, Ipv4Data, Ipv4Frame, Ipv4Data>): ProtocolHandler<this>;
}

type TcpFrame = Ipv4Data;
type TcpData = never;
type TcpHandler<T extends Tcp> = ProtocolHandler<T> & {
    connect(srcIp: Ipv4Address, destIp: Ipv4Address, srcPort: number, destPort: number): TcpSocket;
    listen(serverIp: Ipv4Address, serverPort: number, callback: (socket: TcpSocket) => void): void;
    listenExact(serverIp: Ipv4Address, clientIp: Ipv4Address, serverPort: number, clientPort: number): TcpSocket;
};
type SubProtocol$1 = SubProtocolFor<Tcp>;
declare const handlerPrivateMethodsSymbol: unique symbol;
declare class Tcp<SubProtocols extends {
    [K in string]: SubProtocol$1;
} = any> extends Protocol<TcpFrame, TcpData, TcpFrame, TcpData, SubProtocols> {
    readonly displayName = "TCP";
    readonly ipProtocolNumber = 6;
    constructor(options: Partial<ProtocolOptions<SubProtocols>>);
    createHandler(base: ProtocolHandler<this>, context: HandlerContext<TcpFrame, TcpData, TcpFrame, TcpData>): TcpHandler<this>;
}
type TcpPacket = {
    srcIp: Ipv4Address;
    destIp: Ipv4Address;
    srcPort: number;
    destPort: number;
    seq: number;
    ack: number;
    flags: {
        "ns (deprecated)"?: boolean;
        cwr?: boolean;
        ece?: boolean;
        urg?: boolean;
        ack?: boolean;
        psh?: boolean;
        rst?: boolean;
        syn?: boolean;
        fin?: boolean;
    };
    windowSize?: number;
    urgentPointer?: number;
    options?: Uint8Array;
    data: Uint8Array;
};
declare class TcpSocket {
    readonly isServer: boolean;
    readonly srcIp: Ipv4Address;
    readonly destIp: Ipv4Address;
    readonly srcPort: number;
    readonly destPort: number;
    private _state;
    private _seq;
    private _ack;
    private _onDataCallbacks;
    private _onEstablishedCallbacks;
    private _onCloseCallbacks;
    private _sentPacketsUnacknowledged;
    private _receivedPacketsUnacknowledged;
    private _writeOnceEstablished;
    constructor(isServer: boolean, srcIp: Ipv4Address, destIp: Ipv4Address, srcPort: number, destPort: number);
    protected _onDataCallback(data: TcpPacket): void;
    onData(callback: (data: Uint8Array) => void): void;
    protected _onEstablishedCallback(): void;
    onEstablished(callback: () => void): void;
    protected _onCloseCallback(): void;
    onClose(callback: () => void): void;
    writeUtf8(text: string): void;
    write(data: Uint8Array): void;
    private _writeSinglePacket;
    private _sendPacket;
    close(): void;
    isInitialized(): boolean;
    isClosed(): boolean;
    get connectionString(): string;
    [handlerPrivateMethodsSymbol]: {
        onSendPacketCallbacks: ((data: TcpPacket) => void)[];
        onSendPacketCallback: (packet: TcpPacket) => void;
        listen: () => void;
        connect: () => void;
        process: (tcpPacket: TcpPacket) => void;
    };
}

declare class PostgresConnectionSocket extends EventEmitter implements NetLikeSocketEventEmitter {
    private readonly _tcpHandler;
    private readonly _clientIp;
    private readonly _serverIp;
    private readonly _requestClientPort;
    private readonly _serverPort;
    private _netLikeSocket;
    constructor(_tcpHandler: TcpHandler<Tcp>, _clientIp: Ipv4Address, _serverIp: Ipv4Address, _requestClientPort: () => number, _serverPort: number);
    connect(): void;
    end(): void;
    get writable(): boolean;
    write(data: Uint8Array): boolean;
    destroy(error?: Error): void;
}
interface NetLikeSocketEventEmitter extends EventEmitter {
    on(event: "data", listener: (data: Uint8Array) => void): this;
    on(event: "connect", listener: () => void): this;
    on(event: "close", listener: () => void): this;
}

type IcmpFrame = Ipv4Data;
type IcmpData = {
    srcIp: Ipv4Address;
    destIp: Ipv4Address;
    data: Uint8Array;
} & ({
    type: 0x00 | 0x08;
    code: 0x00;
    identifier: number;
    sequenceNumber: number;
});
type SubProtocol = SubProtocolFor<Icmp>;
type AdditionalOptions$1 = {
    pingServer: Ipv4Address | false;
};
type AdditionalHandlerMethods = {
    ping: (options: Pick<IcmpData, "srcIp" | "destIp">) => Promise<void>;
};
declare class Icmp<SubProtocols extends {
    [K in string]: SubProtocol;
} = any> extends Protocol<IcmpFrame, IcmpData, IcmpFrame, IcmpData, SubProtocols, AdditionalOptions$1> {
    readonly displayName = "ICMP";
    readonly ipProtocolNumber = 1;
    constructor(options: Partial<ProtocolOptions<SubProtocols> & AdditionalOptions$1>);
    createHandler(base: ProtocolHandler<this>, context: HandlerContext<IcmpFrame, IcmpData, IcmpFrame, IcmpData>): ProtocolHandler<this> & AdditionalHandlerMethods;
}

type AdditionalOptions<ReceiveFrame extends object> = {
    consumeIf: (frame: ReceiveFrame) => boolean;
    consoleMessage?: string;
};
declare class Noop<ReceiveFrame extends object> extends Protocol<ReceiveFrame, never, never, never, {}, AdditionalOptions<ReceiveFrame>> {
    readonly displayName = "No-op";
    constructor(options: Partial<ProtocolOptions<{}>> & AdditionalOptions<ReceiveFrame>);
    createHandler(base: ProtocolHandler<this>, context: HandlerContext<ReceiveFrame, never, never, never>): ProtocolHandler<this>;
}

declare class NetworkAdapter {
    private _bus;
    private readonly _onReceiveCallbacks;
    private _ethernet;
    private _router;
    private _isDestroyed;
    get ethernet(): ProtocolHandler<Ethernet<{
        arp: Arp<{
            routerArp: {
                readonly displayName: "RouterARP";
                createHandler(base: ProtocolHandler<any>, context: HandlerContext<ArpData, never, ArpData, never>): ProtocolHandler<any>;
                readonly options: {
                    protocols: {};
                } & Partial<ProtocolOptions<{}>> & {
                    router: Router;
                };
                __hiddenTypeInformationDoesNotExistAtRuntime: {
                    ReceiveFrame: ArpData;
                    ReceiveData: never;
                    SendFrame: ArpData;
                    SendData: never;
                    SubProtocols: {};
                    AdditionalOptions: {
                        router: Router;
                    };
                };
            };
        }>;
        ipv4: Ipv4<{
            icmp: Icmp<any>;
            tcp: Tcp<any>;
            udp: Udp<{
                dhcp: Dhcp<{
                    routerDhcp: {
                        readonly displayName: "RouterDHCP";
                        createHandler(base: ProtocolHandler<any>, context: HandlerContext<DhcpData, never, DhcpData, never>): ProtocolHandler<any>;
                        readonly options: {
                            protocols: {};
                        } & Partial<ProtocolOptions<{}>> & {
                            router: Router;
                        };
                        __hiddenTypeInformationDoesNotExistAtRuntime: {
                            ReceiveFrame: DhcpData;
                            ReceiveData: never;
                            SendFrame: DhcpData;
                            SendData: never;
                            SubProtocols: {};
                            AdditionalOptions: {
                                router: Router;
                            };
                        };
                    };
                }>;
            }>;
        }>;
        ipv6: Noop<EthernetData>;
    }>>;
    get router(): Router;
    constructor(_bus: any);
    onReceive(data: Uint8Array): void;
    send(data: Uint8Array): void;
    startCapture(): {
        stop: () => {
            pcapData: Uint8Array;
        };
    };
    destroy(): void;
    checkNotDestroyed(): void;
}

type SerialConsole = {
    write(data: Uint8Array): void;
    onReceiveByte(callback: (byte: number) => void): void;
};
type PostgresMockCreationOptions = {
    /**
     * Advanced options for expert use cases.
     */
    subtle?: {
        v86Options?: any;
    };
};
declare class PostgresMock {
    private _emulator;
    private _curPort;
    private _curShellScriptId;
    private readonly _serialConsole;
    private constructor();
    /**
     * Creates a new PostgresMock instance.
     *
     * Remember to call `destroy()` on the instance when you're done with it to free up resources.
     *
     * @param options Options for creating the PostgresMock instance. See `PostgresMockCreationOptions` for more information.
     */
    static create(options?: PostgresMockCreationOptions): Promise<PostgresMock>;
    /**
     * Runs a shell command on the Postgres emulator.
     *
     * Does not currently return the output of the command.
     */
    runShellCommand(command: string): void;
    /**
     * Creates a Socket object to communicate with the Postgres instance, similar to but less capable than a net.Socket object.
     */
    createSocket(): PostgresConnectionSocket;
    /**
     * If running on Node.js, serves the Postgres mock on the given port. Returns a Postgres connection URL of the form `postgresql://...@localhost:PORT`.
     */
    listen(port: number): Promise<string>;
    /**
     * Returns a configuration object for a node-postgres ("pg") client.
     *
     * @example
     * ```typescript
     * import { Client } from "pg";
     * import { PostgresMock } from "pgmock";
     *
     * const mock = await PostgresMock.create();
     * const pgClient = new Client(mock.getNodePostgresConfig());
     *
     * // you can use pgClient like any other node-postgres client
     * await pgClient.connect();
     * const res = await pgClient.query('SELECT $1::text as message', ['Hello world!']);
     * Logger.log("Postgres query result:", res);
     *
     * // it's good practice to destroy the mock in the end to prevent memory leaks
     * mock.destroy();
     * ```
     */
    getNodePostgresConfig(): {
        host: string;
        port: number;
        user: string;
        password: string;
        stream: () => net.Socket;
    };
    /**
     * Advanced functionality for PostgresMock, giving direct access to the emulator.
     *
     * This may change in future versions, so use with caution. Useful for debugging and advanced use cases.
     *
     * If you don't know what you're doing, you probably don't need this.
     */
    get subtle(): {
        /**
         * The underlying V86 emulator.
         *
         * For advanced use cases only, as modifying this can break your pgmock setup.
         *
         * Check the [corresponding file in the V86 repository](https://github.com/copy/v86/blob/master/src/browser/starter.js) for more information.
         */
        readonly v86: {
            network_adapter: NetworkAdapter;
            add_listener: (event: string, callback: (e: any) => void) => void;
            serial0_send: (data: string) => void;
            destroy: () => void;
        } | null;
        /**
         * Starts capturing the network traffic between the emulator and the host.
         *
         * When the network capture is stopped, the captured data is returned in the `pcap` format, from where it can be read with tools like Wireshark.
         */
        startNetworkCapture(): {
            stop: () => {
                pcapData: Uint8Array;
            };
        };
        /**
         * The serial terminal interface of the emulator.
         *
         * Meant to be used for visual debugging, and not for programmatic access.
         */
        readonly serialConsole: SerialConsole;
    };
    private _assignPort;
    destroy(): void;
}

export { PostgresMock };
